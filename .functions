#!/usr/bin/env bash


# Utility function to check if $1 command exists
# Use example: if exists ls; then echo "Command exists."; else echo "Command does not exist."; fi
function exists() {
    cmnd=${1:?"Please supply a command to look for."}
    command -v $cmnd >/dev/null 2>&1 && { return 0; } || { return 1; }
}

title() {
    print -Pn "\e]0;$1\a"
}

randomWallpaper() {
    wallpapers=($(ls -d ~/wallpapers/*))
    index=$(($RANDOM % ${#wallpapers[@]} ))
    wallpaper=${wallpapers[$index]}
    echo ${wallpaper}
}

setWallpaper() {
  if [ -f $HOME/.wallpaper ]; then
    feh --bg-scale $HOME/.wallpaper
  else
    setRandomWallpaper
  fi
}

setRandomWallpaper() {
    # Without the echo $RANDOM, result is always the same...
    echo $RANDOM
    wallpaper=$(randomWallpaper)
    echo "Setting wallpaper to ${wallpaper}"
    feh --bg-scale "${wallpaper}"
}

getInstalledPackages() {
    packages=$(pacman -Qm; yaourt -Qm; yaourt -Qmd; yaourt -Qme; yaourt -Qmed)
    echo ${packages} | sort | uniq

}

install() {
    yaourt --needed -S $@
}

uninstall() {
    yaourt -R $@
}


detect_os() {

    ## OS and Architecture

    if [ -f /etc/os-release ]; then
        # freedesktop.org and systemd
        . /etc/os-release
        OS=$NAME
        VER=$VERSION_ID
    elif type lsb_release >/dev/null 2>&1; then
        # linuxbase.org
        OS=$(lsb_release -si)
        VER=$(lsb_release -sr)
    elif [ -f /etc/lsb-release ]; then
        # For some versions of Debian/Ubuntu without lsb_release command
        . /etc/lsb-release
        OS=$DISTRIB_ID
        VER=$DISTRIB_RELEASE
    elif [ -f /etc/debian_version ]; then
        # Older Debian/Ubuntu/etc.
        OS=Debian
        VER=$(cat /etc/debian_version)
    elif [ -f /etc/SuSe-release ]; then
        # Older SuSE/etc.
        ...
    elif [ -f /etc/redhat-release ]; then
        # Older Red Hat, CentOS, etc.
        ...
    else
        # Fall back to uname, e.g. "Linux <version>", also works for BSD, etc.
        OS=$(uname -s)
        VER=$(uname -r)
    fi

}


# @see https://github.com/kepkin/dev-shell-essentials/blob/master/highlight.sh
highlight() {
    declare -A fg_color_map
    fg_color_map[black]=30
    fg_color_map[red]=31
    fg_color_map[green]=32
    fg_color_map[yellow]=33
    fg_color_map[blue]=34
    fg_color_map[magenta]=35
    fg_color_map[cyan]=36

    fg_c=$(echo -e "\e[1;${fg_color_map[$1]}m")
    c_rs=$'\e[0m'
    sed -u s"/$2/$fg_c\0$c_rs/g"
}


setup_lsi() {

    if exists ls-i;
    then
        LS_COLORS=$(ls_colors_generator)

        run_ls() {
            ls-i --color=auto -w $(tput cols) "$@"
        }

        run_dir() {
            dir-i --color=auto -w $(tput cols) "$@"
        }

        run_vdir() {
            vdir-i --color=auto -w $(tput cols) "$@"
        }
        #alias ls="run_ls"
        #alias dir="run_dir"
        #alias vdir="run_vdir"
    fi
}


grepc() {
    pattern=$1
    shift
    if [ ! -z $2 ]; then
    esc=$(printf "\0\$2")
    shift
    else
    esc=$(printf "\033")
    fi
    sed -E 's"'"$pattern"'"'$esc'[32m&'$esc'[0m"g' "$@"
}


histcmd() {
    fc -l 1 |  awk '{line=$1; $1=""; CMD_LINE[$0]=line; CMD[$0]++;count++; for (a in CMD)print CMD[a] " " CMD_LINE[a] " " a;}' | sort -rn
}


r(){
    source $HOME/.zshrc
}


function validate-yml()
{
	#!/bin/bash

	#
	# Efstathios Xagoraris <sxagoraris@gmail.com>
	# Validate YAML files using ruby
	#


	if [ $# -eq 0 ]
	  then
		echo "Please provide a yaml file as argument eg $0 file.yaml"
		exit 1
	fi

	ruby -ryaml -e "YAML.parse(File.open('${1}'))"

	if [[ $? -ne 0 ]]
	  then
		echo "$1 is not valid YAML"
	  else
		echo "$1 is a valid YAML"
	fi
}

current_tmux_window() {
    display_time=$(tmux show-options -g display-time | grep -o '[0-9]*')

    tmux set-option -g display-time 1
    tmux display-message
    tmux set-option -g display-time $display_time

    export TMUX_WINDOW=$(tmux show-messages | tail -1 | grep -o 'current pane \([0-9]\)' | grep -o '[0-9]*')
    echo $TMUX_WINDOW
}

notify-on-error() {
    tmp_file=$(mktemp)\
    ARGS="$@"
    eval $ARGS 2>$tmp_file
    result=$?

    if [ $result -ne 0 ]; then
        error_content="$(cat $tmp_file)"
        echo $error_content
        notify-send -u critical -i status/important "Command failed!" "$ARGS\n$error_content"
    fi
}

notify-finished() {
    ARGS="$@"
    result=$?
    notify-on-error $ARGS
    if [ $result -eq 0 ]; then
        notify-send "Command Finished!" "$ARGS"
    fi
}

webdev () {
    action="$1"
    version="$2"
    service="$3"

    if [ -z "$action" ]; then
        echo "Please provide the action as the first parameter (up|stop|logs)"
        exit 2
    fi

    if [ -z "$version" ] && [ "$action" != 'stop' ]; then
        echo "Please provide the version as the second parameter (56|71|72)"
        exit 3
    fi

    cd "$DOCKER_REPO_LOCATION"

    if [ "$action" = "up" ]; then
        echo "Stopping web[0-9]* containers"
        docker ps -f "name=web[0-9]*" --format "{{.ID}}" | xargs docker kill
        cd "$DOCKER_REPO_LOCATION/Web${version}"
        echo "Upping ${version}..."
        docker-compose -f minimal.yml up -d --force-recreate
    elif [ "$action" = "stop" ]; then
        echo "Stopping web[0-9]* containers"
        docker ps -f "name=web[0-9]*" --format "{{.ID}}" | xargs docker kill
    elif [ "$action" = "logs" ]; then
        cd "$DOCKER_REPO_LOCATION/Web${version}"
        docker-compose logs --tail 100 -f $service
    else
        echo "Action ${action} is not recognized..."
        exit 4
    fi
}

ip_address() {
    ip route get 1 | awk '{print $NF;exit}'
}
