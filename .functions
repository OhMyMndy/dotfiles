#!/usr/bin/env bash


# Utility function to check if $1 command exists
# Use example: if exists ls; then echo "Command exists."; else echo "Command does not exist."; fi
exists() {
    cmnd=${1:?"Please supply a command to look for."}
    command -v $cmnd >/dev/null 2>&1 && { return 0; } || { return 1; }
}

title() {
    print -Pn "\e]0;$1\a"
}

randomWallpaper() {
    cd ~/wallpapers
    wallpapers=($(find $PWD/ -type f -exec file {} \; | awk -F: '{ if ($2 ~/[Ii]mage|EPS/) print $1}' ))
    index=$(($RANDOM % ${#wallpapers[@]} ))
    wallpaper=${wallpapers[$index]}
    echo ${wallpaper}
}

setWallpaper() {
  wallpaper_file="$1"

  if [ "$wallpaper_file" != '' ] && [ -f "$wallpaper_file" ]; then
    rm ~/.wallpaper 2>/dev/null
    ln -s "$wallpaper_file" ~/.wallpaper
  fi

  if [ -f $HOME/.wallpaper ]; then
    feh --bg-fill $HOME/.wallpaper
  else
    setRandomWallpaper
  fi
}

setRandomWallpaper() {
    # Without the echo $RANDOM, result is always the same...
    echo $RANDOM
    wallpaper=$(randomWallpaper)
    echo "Setting wallpaper to ${wallpaper}"
    feh --bg-fill "${wallpaper}"
}

getInstalledPackages() {
    packages=$(pacman -Qm; yaourt -Qm; yaourt -Qmd; yaourt -Qme; yaourt -Qmed)
    echo ${packages} | sort | uniq

}

install() {
    yaourt --needed -S $@
}

uninstall() {
    yaourt -R $@
}


detect_os() {

    ## OS and Architecture

    if [ -f /etc/os-release ]; then
        # freedesktop.org and systemd
        . /etc/os-release
        OS=$NAME
        VER=$VERSION_ID
    elif type lsb_release >/dev/null 2>&1; then
        # linuxbase.org
        OS=$(lsb_release -si)
        VER=$(lsb_release -sr)
    elif [ -f /etc/lsb-release ]; then
        # For some versions of Debian/Ubuntu without lsb_release command
        . /etc/lsb-release
        OS=$DISTRIB_ID
        VER=$DISTRIB_RELEASE
    elif [ -f /etc/debian_version ]; then
        # Older Debian/Ubuntu/etc.
        OS=Debian
        VER=$(cat /etc/debian_version)
    elif [ -f /etc/SuSe-release ]; then
        # Older SuSE/etc.
        ...
    elif [ -f /etc/redhat-release ]; then
        # Older Red Hat, CentOS, etc.
        ...
    else
        # Fall back to uname, e.g. "Linux <version>", also works for BSD, etc.
        OS=$(uname -s)
        VER=$(uname -r)
    fi

}


# @see https://github.com/kepkin/dev-shell-essentials/blob/master/highlight.sh
highlight() {
    declare -A fg_color_map
    fg_color_map[black]=30
    fg_color_map[red]=31
    fg_color_map[green]=32
    fg_color_map[yellow]=33
    fg_color_map[blue]=34
    fg_color_map[magenta]=35
    fg_color_map[cyan]=36

    fg_c=$(echo -e "\e[1;${fg_color_map[$1]}m")
    c_rs=$'\e[0m'
    sed -u s"/$2/$fg_c\0$c_rs/g"
}


setup_lsi() {

    if exists ls-i;
    then
        LS_COLORS=$(ls_colors_generator)

        run_ls() {
            ls-i --color=auto -w $(tput cols) "$@"
        }

        run_dir() {
            dir-i --color=auto -w $(tput cols) "$@"
        }

        run_vdir() {
            vdir-i --color=auto -w $(tput cols) "$@"
        }
        #alias ls="run_ls"
        #alias dir="run_dir"
        #alias vdir="run_vdir"
    fi
}


grepc() {
    pattern=$1
    shift
    if [ ! -z $2 ]; then
    esc=$(printf "\0\$2")
    shift
    else
    esc=$(printf "\033")
    fi
    sed -E 's"'"$pattern"'"'$esc'[32m&'$esc'[0m"g' "$@"
}


histcmd() {
    fc -l 1 |  awk '{line=$1; $1=""; CMD_LINE[$0]=line; CMD[$0]++;count++; for (a in CMD)print CMD[a] " " CMD_LINE[a] " " a;}' | sort -rn
}


r(){
    source $HOME/.zshrc
}


function validate-yml()
{
	#!/bin/bash

	#
	# Efstathios Xagoraris <sxagoraris@gmail.com>
	# Validate YAML files using ruby
	#


	if [ $# -eq 0 ]
	  then
		echo "Please provide a yaml file as argument eg $0 file.yaml"
		exit 1
	fi

	ruby -ryaml -e "YAML.parse(File.open('${1}'))"

	if [[ $? -ne 0 ]]
	  then
		echo "$1 is not valid YAML"
	  else
		echo "$1 is a valid YAML"
	fi
}

current_tmux_window() {
    display_time=$(tmux show-options -g display-time | grep -o '[0-9]*')

    tmux set-option -g display-time 1
    tmux display-message
    tmux set-option -g display-time $display_time

    export TMUX_WINDOW=$(tmux show-messages | tail -1 | grep -o 'current pane \([0-9]\)' | grep -o '[0-9]*')
    echo $TMUX_WINDOW
}

notify-on-error() {
    tmp_file=$(mktemp)\
    ARGS="$@"
    eval $ARGS 2>$tmp_file
    result=$?

    if [ $result -ne 0 ]; then
        error_content="$(cat $tmp_file)"
        echo $error_content
        notify-send -u critical -i status/important "Command failed!" "$ARGS\n$error_content"
    fi
}

notify-finished() {
    ARGS="$@"
    result=$?
    notify-on-error $ARGS
    if [ $result -eq 0 ]; then
        notify-send "Command Finished!" "$ARGS"
    fi
}

webdev () {
    action="$1"
    version="$2"
    service="$3"

    if [ -z "$action" ]; then
        echo "Please provide the action as the first parameter (up|stop|logs)"
        exit 2
    fi

    if [ -z "$version" ] && [ "$action" != 'stop' ]; then
        echo "Please provide the version as the second parameter (56|71|72)"
        exit 3
    fi

    cd "$DOCKER_REPO_LOCATION"

    if [ "$action" = "up" ]; then
        echo "Stopping web[0-9]* containers"
        docker ps -f "name=web[0-9]*" --format "{{.ID}}" | xargs docker kill
        cd "$DOCKER_REPO_LOCATION/Web${version}"
        echo "Upping ${version}..."
        docker-compose -f minimal.yml up -d --force-recreate
    elif [ "$action" = "stop" ]; then
        echo "Stopping web[0-9]* containers"
        docker ps -f "name=web[0-9]*" --format "{{.ID}}" | xargs docker kill
    elif [ "$action" = "logs" ]; then
        cd "$DOCKER_REPO_LOCATION/Web${version}"
        docker-compose logs --tail 100 -f $service
    else
        echo "Action ${action} is not recognized..."
        exit 4
    fi
}

ip_address() {
    ip route get 1 | awk '{print $7;exit}'
}

write_apm_to_file() {
  apm list --installed --bare > ~/dotfiles/apm-packages.txt
}

# make sure you pass absolute paths
# encrypt_files "$(find $(pwd) -name '*.jpg')" # $(pwd) makes sure it is absolute
encrypt_files() {
  files="$@"
  echo "Enter password:"
  read -s password
  echo "$files" | xargs -I {} sh -c "echo \"$password\" | gpg --passphrase-fd 0 --always-trust --compress-algo BZIP2 -z 9 --symmetric {}"
}

decrypt_if_necessary() {
  files="$1"
  unset password
  IFS=$'\n'
  echo "$files" | while read file; do
  	original=$(echo "$file" | sed -E 's/\.gpg//g')
  	if [ ! -f "$original" ]; then
  		if [ ! "$password" ]; then
  			echo "Enter password to decrypt GPG encrypted files"
  			read -s password</dev/tty
  		fi
  		echo "$password" | gpg --passphrase-fd 0 -d -o "$original" "$file"
  	fi
  done
  unset password
}


remove_wine_desktop_files() {
  find /home/mandy/.local/share/applications/ | sort \
    | grep wine-extension \
    | grep -v application.desktop \
    | grep -v appref-ms \
    | grep -v vbs \
    | grep -v msp \
    | grep -v hlp \
    | grep -v url \
    | xargs -I {} rm {}
}

create_remmina_desktop_files() {
  rm ~/.local/share/applications/remmina-connection-*
  find ~/.remmina -type f -name '*.remmina' | while read file; do
    name="$(grep '^name=' $file | cut -d'=' -f2)"
    name_formatted=$(echo "$name" | sed -E 's/[^a-zA-Z0-9]/_/g')
    cat <<EOL | tee  ~/.local/share/applications/remmina-connection-$name_formatted.desktop >/dev/null
[Desktop Entry]
Name=Remmina - $name
Exec=remmina -c $file
Icon=appimagekit-remmina
Type=Application
Categories=GTK;GNOME;X-GNOME-NetworkSettings;Network;
EOL
  done
}

create_vm() {
  type="$1"
  name="$2"

  vboxmanage showvminfo "$name" >/dev/null 2>&1
  result=$?

  if [ $result -eq 0 ]; then
    echo "VM with name '$name' is already imported!"
    return
  fi


  TPATH=$(VBoxManage list systemproperties | sed -n 's/Default machine folder: *//p')

  VBoxManage createvm --name "$name" --ostype "$type" --register
  if [ $? -ne 0 ]; then
    echo "Possible os types:"
    VBoxManage list ostypes | grep '^ID'
    return
  fi


  echo "Creating harddisk..."
  disk_file="$TPATH/$name/$name.vmdk"
  VBoxManage createmedium disk --filename "$disk_file" --size 80000 --format VMDK --variant Split2G
  #VBoxManage internalcommands sethduuid "$disk_file"

  VBoxManage storagectl "$name" --name "SATA Controller" --add sata --controller IntelAHCI
  VBoxManage storageattach "$name" --storagectl "SATA Controller" --port 0 --device 0 --type hdd --medium "$disk_file"

  VBoxManage storagectl "$name" --name "IDE Controller" --add ide
  VBoxManage storageattach "$name" --storagectl "IDE Controller" --type dvddrive --medium emptydrive  --port 0 --device 0
  VBoxManage modifyvm "$name" --accelerate3d on --usb on --vram 128 --memory 2048 --clipboard bidirectional --draganddrop bidirectional
  VBoxManage modifyvm "$name" --boot1 dvd --boot2 disk --boot3 none --boot4 none
  VBoxManage modifyvm "$name" --ioapic on --cpus 2 --cpuexecutioncap 80
  # $ VBoxManage modifyvm $VM --nic1 bridged --bridgeadapter1 e1000g0
}
